"Aún no tratado" = "#C4D7E0",
"Se trata este año" = "#8E7DBE",
"Ya tratado" = "steelblue4"
)
) +
scale_x_continuous(breaks = scales::pretty_breaks()) +
labs(
x = "Año",
y = "Número de manzanas",
fill = "") +
theme_minimal(base_size = 14)
treat_year
ggsave("results/fig_treat_year_obs.pdf", treat_year, width = 8, height = 5)
# ---------------------#
# Simulación de datos  #
# ---------------------#
# Semilla y entorno
rm(list = ls())
set.seed(12345)
# Paquetes
library(foreign)   # para leer el DBF de manzanas
library(dplyr)     # para manipulación de datos
library(tidyr)     # para multiplicar el panel
library(fixest)    # para regresiones con efectos fijos y estudio de eventos
library(ggplot2)
library(fixes)
library(sf)
# ------------------------------------------------------------
# Leer y limpiar datos
# ------------------------------------------------------------
setwd("C:/Users/USUARIO/Documents/GitHub/TF_EU_STCH")
manzanas <- st_read("data/intermediate/R/manzanas.shp")
# Cambiar nombres de variables
# mancodigo -> id_manzana
# treatment -> treated
# treatment_ -> treat_year
# cod_upz -> upz_id
manzanas <- manzanas %>%
rename(
id_manzana = mancodigo,
treated    = treatment,
treat_year = treatment_,
upz_id     = cod_upz
)
# Convertir el año de tratamiento (staggered) a numérica
manzanas <- manzanas %>%
mutate(
treat_year = as.numeric(treat_year),
treated    = as.numeric(treated)
)
# Sacar observaciones sin UPZ --> coinciden con calles
manzanas <- manzanas %>%
filter(upz_id != "" & !is.na(upz_id))
# ------------------------------------------------------------
# Crear panel de 2016 a 2026
# ------------------------------------------------------------
years <- 2016:2026
panel <- manzanas %>%
tidyr::crossing(year = years) %>%
arrange(upz_id, id_manzana, year)
# ------------------------------------------------------------
# Variables de tiempo con respecto al evento y efectos fijos
# ------------------------------------------------------------
# Tiempo con respecto al evento solo para tratados
panel <- panel %>%
mutate(
event_time = ifelse(treated == 1, year - treat_year, NA_real_)
)
# Efectos fijos de manzana --> distribución normal con media 0 y SD 0.5.
# Fijos para todos los años.
id_df <- panel %>%
distinct(id_manzana) %>%
mutate(manzana_fe = rnorm(n(), mean = 0, sd = 0.5))
panel <- panel %>%
left_join(id_df, by = "id_manzana")
# Efectos fijos de año --> tendencia lineal común
panel <- panel %>%
mutate(
year_fe = 0.02 * year
)
# ------------------------------------------------------------
# Covariables - Crimen y población
# ------------------------------------------------------------
# Generar caminata aleatoria truncada en grupos
gen_rw_truncated <- function(n, mu0, sd0, mu_step, sd_step, lower, upper) {
x <- numeric(n)
x[1] <- round(rnorm(1, mean = mu0, sd = sd0))
if (n > 1) {
for (t in 2:n) {
x[t] <- round(x[t - 1] + rnorm(1, mean = mu_step, sd = sd_step))
}
}
x <- pmax(pmin(x, upper), lower)
return(x)
}
# Generar las variables
panel <- panel %>%
group_by(id_manzana) %>%
arrange(year, .by_group = TRUE) %>%
mutate(
# Crimen -- Caminata aleatoria alrededor de media inicial 3, SD 12, y movimiento ~ N(0,2) para tener crecimientos y caídas
viol = gen_rw_truncated(
n = n(),
mu0 = 3, sd0 = 12,
mu_step = 0, sd_step = 2,
lower = 0, upper = 200
)
) %>%
ungroup()
# Población -- Caminata aleatoria alrededor de media inicial 260, SD 400, movimiento ~ N(1,2) para tendencia creciente pero igual con ciertas caídas
gen_pop_truncated <- function(n, mu0, sd0, mu_step, sd_step, lower, upper) {
x <- numeric(n)
x[1] <- round(rnorm(1, mean = mu0, sd = sd0))
if (n > 1) {
for (t in 2:n) {
x[t] <- x[t - 1] + round(rnorm(1, mean = mu_step, sd = sd_step))
}
}
x <- pmax(pmin(x, upper), lower)
return(x)
}
panel <- panel %>%
group_by(id_manzana) %>%
arrange(year, .by_group = TRUE) %>%
mutate(
population = gen_pop_truncated(
n = n(),
mu0 = 260, sd0 = 400,
mu_step = 1, sd_step = 2,
lower = 260, upper = 12273
)
) %>%
ungroup()
# Transformar crimen a tasa de crimen per cápita por manzana
panel <- panel %>%
mutate(
viol_pc = (viol / population) * 100
)
# ------------------------------------------------------------
# Efectos de tratamiento (Average Treatment on Treated paths)
# ------------------------------------------------------------
# Se crean para dos variables de resultado, precios de oferta (Bid-price) y para ventas realizadas (Sale-price)
# Bid-price ATT
panel <- panel %>%
mutate(
te = 0
)
# Inicia con una caída grande en el primer año, luego la caída se atenúa, y al final el efecto es positivo.
panel <- panel %>%
mutate(
te = ifelse(treated == 1 & !is.na(event_time) & year >= treat_year,
-0.02 * (event_time + 1), te),
te = ifelse(treated == 1 & !is.na(event_time) & year >= treat_year & event_time > 2,
-0.01 * (event_time + 1), te),
te = ifelse(treated == 1 & !is.na(event_time) & year >= treat_year & event_time > 3,
0.005 * (event_time + 1), te)
)
# Sale-price ATT (tesal)
panel <- panel %>%
mutate(
tesal = 0
)
# Iniciamos con una caída más grande que para bids, que luego se atenúa y también se vuelve positiva
# Refleja que las ventas también incluyen el comportamiento de la demanda, los oferentes son más reticentes a bajar los precios por sí solos.
panel <- panel %>%
mutate(
tesal = ifelse(treated == 1 & !is.na(event_time) & year >= treat_year,
-0.05 * (event_time + 1), tesal),
tesal = ifelse(treated == 1 & !is.na(event_time) & year >= treat_year & event_time > 1,
0.01 * (event_time + 1), tesal),
tesal = ifelse(treated == 1 & !is.na(event_time) & year >= treat_year & event_time > 2,
0.02 * (event_time + 1), tesal)
)
# ------------------------------------------------------------
# Estructura del error: Error espacial + Proceso autorregresivo AR(1) en el tiempo
# ------------------------------------------------------------
rho_spatial <- 0.4 # Porcentaje espacial del error total.
sigma2_tot  <- 1.1 # --> Error total
# Variance decomposition
sigma2_u <- rho_spatial * sigma2_tot
sigma2_e <- (1 - rho_spatial) * sigma2_tot
sigma_u <- sqrt(sigma2_u)
sigma_e <- sqrt(sigma2_e)
# Coeficiente de persistencia del AR(1)
phi_t <- 0.7
# Creamos un error para el AR(1) que cumpla con que la varianza de este error es igual a sigma2_e si el proceso es estacionario.
sigma2_eta <- sigma2_e * (1 - phi_t^2)
sigma_eta  <- sqrt(sigma2_eta)
# ------------------------------------------------------------
# Choque espacial a nivel de UPZ para crear los clústers
# ------------------------------------------------------------
# El efecto estático de pertenecer a una UPZ particular viene de una normal con media 0 y desviación igual al error espacial.
upz_shocks <- panel %>%
distinct(upz_id) %>%
mutate(
u_q = rnorm(n(), mean = 0, sd = sigma_u)
)
panel <- panel %>%
left_join(upz_shocks, by = "upz_id")
# ------------------------------------------------------------
# Creamos el AR(1)
# ------------------------------------------------------------
panel <- panel %>%
group_by(id_manzana) %>%
arrange(year, .by_group = TRUE) %>%
mutate(
e_it = {
nT <- n()
e_vec <- numeric(nT)
# Primer periodo
e_vec[1] <- rnorm(1, mean = 0, sd = sigma_e)
# Siguientes periodos
if (nT > 1) {
for (t in 2:nT) {
eta_t   <- rnorm(1, mean = 0, sd = sigma_eta) # metemos el error que creamos para el AR.
e_vec[t] <- phi_t * e_vec[t - 1] + eta_t
}
}
e_vec
}
) %>%
ungroup()
# El error total es el proveniente del AR(1) sumado con el proveniente del choque espacial.
panel <- panel %>%
mutate(
eps = e_it + u_q
)
# ------------------------------------------------------------
# Crear la relación/el modelo verdadero para bid-price
# ------------------------------------------------------------
panel <- panel %>%
mutate(
log_price = 10 + year_fe + manzana_fe - 0.20 * viol_pc + te + eps,
treatment = as.integer(treated == 1 & year >= treat_year)
)
# ------------------------------------------------------------
# Estimar la relación por medio de TWFE para bid-price
# ------------------------------------------------------------
mod_bid_twfe <- feols(
log_price ~ treatment + viol_pc | id_manzana + year,
cluster = ~ id_manzana + upz_id,
data = panel
)
# ------------------------------------------------------------
# Crear la variable y relación para ventas realizadas
# ------------------------------------------------------------
# Selección aleatoria de observaciones de bids. Uniforme entre 0–1, borramos 55% de las observaciones asumiendo que hay muchas menos ventas que ofertas.
panel <- panel %>%
mutate(
# Creamos la uniforme para decidir qué observaciones se quedan en ventas
sells      = runif(n()),
dumm_sales = as.integer(sells >= 0.45),
# Simulamos el log del precio de venta -- asume ef de año, de manzana, y asume el efecto de tratamiento, con error AR1.
log_price_sales = 10 + year_fe + manzana_fe + 0.20 * viol_pc + tesal + eps,
# Dejamos en missing las observaciones que se sacan para ventas
log_price_sales = ifelse(dumm_sales == 1, NA_real_, log_price_sales)
)
panel_exp <- panel %>%
st_drop_geometry() %>%
as.data.frame()
write_sf(panel_exp, "data/final/simulacion.shp")
# ---------------------#
# Simulación de datos  #
# ---------------------#
# Semilla y entorno
rm(list = ls())
set.seed(12345)
# Paquetes
library(foreign)   # para leer el DBF de manzanas
library(dplyr)     # para manipulación de datos
library(tidyr)     # para multiplicar el panel
library(fixest)    # para regresiones con efectos fijos y estudio de eventos
library(ggplot2)
library(fixes)
library(sf)
# ------------------------------------------------------------
# Leer y limpiar datos
# ------------------------------------------------------------
setwd("C:/Users/USUARIO/Documents/GitHub/TF_EU_STCH")
manzanas <- st_read("data/intermediate/R/manzanas.shp")
# Cambiar nombres de variables
# mancodigo -> id_manzana
# treatment -> treated
# treatment_ -> treat_year
# cod_upz -> upz_id
manzanas <- manzanas %>%
rename(
id_manzana = mancodigo,
treated    = treatment,
treat_year = treatment_,
upz_id     = cod_upz
)
# Convertir el año de tratamiento (staggered) a numérica
manzanas <- manzanas %>%
mutate(
treat_year = as.numeric(treat_year),
treated    = as.numeric(treated)
)
# Sacar observaciones sin UPZ --> coinciden con calles
manzanas <- manzanas %>%
filter(upz_id != "" & !is.na(upz_id))
# ------------------------------------------------------------
# Crear panel de 2016 a 2026
# ------------------------------------------------------------
years <- 2016:2026
panel <- manzanas %>%
tidyr::crossing(year = years) %>%
arrange(upz_id, id_manzana, year)
# ------------------------------------------------------------
# Variables de tiempo con respecto al evento y efectos fijos
# ------------------------------------------------------------
# Tiempo con respecto al evento solo para tratados
panel <- panel %>%
mutate(
event_time = ifelse(treated == 1, year - treat_year, NA_real_)
)
# Efectos fijos de manzana --> distribución normal con media 0 y SD 0.5.
# Fijos para todos los años.
id_df <- panel %>%
distinct(id_manzana) %>%
mutate(manzana_fe = rnorm(n(), mean = 0, sd = 0.5))
panel <- panel %>%
left_join(id_df, by = "id_manzana")
# Efectos fijos de año --> tendencia lineal común
panel <- panel %>%
mutate(
year_fe = 0.02 * year
)
# ------------------------------------------------------------
# Covariables - Crimen y población
# ------------------------------------------------------------
# Generar caminata aleatoria truncada en grupos
gen_rw_truncated <- function(n, mu0, sd0, mu_step, sd_step, lower, upper) {
x <- numeric(n)
x[1] <- round(rnorm(1, mean = mu0, sd = sd0))
if (n > 1) {
for (t in 2:n) {
x[t] <- round(x[t - 1] + rnorm(1, mean = mu_step, sd = sd_step))
}
}
x <- pmax(pmin(x, upper), lower)
return(x)
}
# Generar las variables
panel <- panel %>%
group_by(id_manzana) %>%
arrange(year, .by_group = TRUE) %>%
mutate(
# Crimen -- Caminata aleatoria alrededor de media inicial 3, SD 12, y movimiento ~ N(0,2) para tener crecimientos y caídas
viol = gen_rw_truncated(
n = n(),
mu0 = 3, sd0 = 12,
mu_step = 0, sd_step = 2,
lower = 0, upper = 200
)
) %>%
ungroup()
# Población -- Caminata aleatoria alrededor de media inicial 260, SD 400, movimiento ~ N(1,2) para tendencia creciente pero igual con ciertas caídas
gen_pop_truncated <- function(n, mu0, sd0, mu_step, sd_step, lower, upper) {
x <- numeric(n)
x[1] <- round(rnorm(1, mean = mu0, sd = sd0))
if (n > 1) {
for (t in 2:n) {
x[t] <- x[t - 1] + round(rnorm(1, mean = mu_step, sd = sd_step))
}
}
x <- pmax(pmin(x, upper), lower)
return(x)
}
panel <- panel %>%
group_by(id_manzana) %>%
arrange(year, .by_group = TRUE) %>%
mutate(
population = gen_pop_truncated(
n = n(),
mu0 = 260, sd0 = 400,
mu_step = 1, sd_step = 2,
lower = 260, upper = 12273
)
) %>%
ungroup()
# Transformar crimen a tasa de crimen per cápita por manzana
panel <- panel %>%
mutate(
viol_pc = (viol / population) * 100
)
# ------------------------------------------------------------
# Efectos de tratamiento (Average Treatment on Treated paths)
# ------------------------------------------------------------
# Se crean para dos variables de resultado, precios de oferta (Bid-price) y para ventas realizadas (Sale-price)
# Bid-price ATT
panel <- panel %>%
mutate(
te = 0
)
# Inicia con una caída grande en el primer año, luego la caída se atenúa, y al final el efecto es positivo.
panel <- panel %>%
mutate(
te = ifelse(treated == 1 & !is.na(event_time) & year >= treat_year,
-0.02 * (event_time + 1), te),
te = ifelse(treated == 1 & !is.na(event_time) & year >= treat_year & event_time > 2,
-0.01 * (event_time + 1), te),
te = ifelse(treated == 1 & !is.na(event_time) & year >= treat_year & event_time > 3,
0.005 * (event_time + 1), te)
)
# Sale-price ATT (tesal)
panel <- panel %>%
mutate(
tesal = 0
)
# Iniciamos con una caída más grande que para bids, que luego se atenúa y también se vuelve positiva
# Refleja que las ventas también incluyen el comportamiento de la demanda, los oferentes son más reticentes a bajar los precios por sí solos.
panel <- panel %>%
mutate(
tesal = ifelse(treated == 1 & !is.na(event_time) & year >= treat_year,
-0.05 * (event_time + 1), tesal),
tesal = ifelse(treated == 1 & !is.na(event_time) & year >= treat_year & event_time > 1,
0.01 * (event_time + 1), tesal),
tesal = ifelse(treated == 1 & !is.na(event_time) & year >= treat_year & event_time > 2,
0.02 * (event_time + 1), tesal)
)
# ------------------------------------------------------------
# Estructura del error: Error espacial + Proceso autorregresivo AR(1) en el tiempo
# ------------------------------------------------------------
rho_spatial <- 0.4 # Porcentaje espacial del error total.
sigma2_tot  <- 1.1 # --> Error total
# Variance decomposition
sigma2_u <- rho_spatial * sigma2_tot
sigma2_e <- (1 - rho_spatial) * sigma2_tot
sigma_u <- sqrt(sigma2_u)
sigma_e <- sqrt(sigma2_e)
# Coeficiente de persistencia del AR(1)
phi_t <- 0.7
# Creamos un error para el AR(1) que cumpla con que la varianza de este error es igual a sigma2_e si el proceso es estacionario.
sigma2_eta <- sigma2_e * (1 - phi_t^2)
sigma_eta  <- sqrt(sigma2_eta)
# ------------------------------------------------------------
# Choque espacial a nivel de UPZ para crear los clústers
# ------------------------------------------------------------
# El efecto estático de pertenecer a una UPZ particular viene de una normal con media 0 y desviación igual al error espacial.
upz_shocks <- panel %>%
distinct(upz_id) %>%
mutate(
u_q = rnorm(n(), mean = 0, sd = sigma_u)
)
panel <- panel %>%
left_join(upz_shocks, by = "upz_id")
# ------------------------------------------------------------
# Creamos el AR(1)
# ------------------------------------------------------------
panel <- panel %>%
group_by(id_manzana) %>%
arrange(year, .by_group = TRUE) %>%
mutate(
e_it = {
nT <- n()
e_vec <- numeric(nT)
# Primer periodo
e_vec[1] <- rnorm(1, mean = 0, sd = sigma_e)
# Siguientes periodos
if (nT > 1) {
for (t in 2:nT) {
eta_t   <- rnorm(1, mean = 0, sd = sigma_eta) # metemos el error que creamos para el AR.
e_vec[t] <- phi_t * e_vec[t - 1] + eta_t
}
}
e_vec
}
) %>%
ungroup()
# El error total es el proveniente del AR(1) sumado con el proveniente del choque espacial.
panel <- panel %>%
mutate(
eps = e_it + u_q
)
# ------------------------------------------------------------
# Crear la relación/el modelo verdadero para bid-price
# ------------------------------------------------------------
panel <- panel %>%
mutate(
log_price = 10 + year_fe + manzana_fe - 0.20 * viol_pc + te + eps,
treatment = as.integer(treated == 1 & year >= treat_year)
)
# ------------------------------------------------------------
# Estimar la relación por medio de TWFE para bid-price
# ------------------------------------------------------------
mod_bid_twfe <- feols(
log_price ~ treatment + viol_pc | id_manzana + year,
cluster = ~ id_manzana + upz_id,
data = panel
)
# ------------------------------------------------------------
# Crear la variable y relación para ventas realizadas
# ------------------------------------------------------------
# Selección aleatoria de observaciones de bids. Uniforme entre 0–1, borramos 55% de las observaciones asumiendo que hay muchas menos ventas que ofertas.
panel <- panel %>%
mutate(
# Creamos la uniforme para decidir qué observaciones se quedan en ventas
sells      = runif(n()),
dumm_sales = as.integer(sells >= 0.45),
# Simulamos el log del precio de venta -- asume ef de año, de manzana, y asume el efecto de tratamiento, con error AR1.
log_price_sales = 10 + year_fe + manzana_fe - 0.20 * viol_pc + tesal + eps,
# Dejamos en missing las observaciones que se sacan para ventas
log_price_sales = ifelse(dumm_sales == 1, NA_real_, log_price_sales)
)
panel_exp <- panel %>%
st_drop_geometry() %>%
as.data.frame()
write_sf(panel_exp, "data/final/simulacion.shp")
### 4. Estadísticas Descriptivas y Gráficos
*   **Script:** `04.descriptivas.R`
### **Las capas y mapas generados a través de ArcGIS se encuentran en las carpetas "data/intermediate/ArcGIS" y "Results", respectivamente.**
